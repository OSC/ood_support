module OodSupport
  # A helper object that describes an access control list (ACL) with entries
  class ACL
    include Comparable

    # The entries of this ACL
    # @return [Array<ACLEntry>] list of entries
    attr_reader :entries

    # Generate an ACL by parsing a string
    # @param acl [#to_s] string describing acl
    # @return [ACL] ACL generated by string
    def self.parse(acl:)
      entries = []
      acl.to_s.strip.split(/\n|,/).grep(/^[^#]/) do |entry|
        entries << ACLEntry.parse(entry: entry)
      end
      new(entries: entries)
    end

    # @param entries [Array<ACLEntry>] list of entries
    def initialize(entries:)
      @entries = entries
    end

    # Check if queried principle has access to resource
    # @return [Boolean] does principle have access?
    def allow?(principle:)
      # Check in array order and default deny
      ordered_check(principle: principle, default: false)
    end

    # Convert object to string
    # @return [String] the string describing this object
    def to_s
      entries.join("\n")
    end

    # The comparison operator for sorting values
    # @param other [#to_s] entry to compare against
    # @return [Boolean] how acls compare
    def <=>(other)
      to_s <=> other
    end

    # Checks whether two ACL objects are completely identical to each other
    # @param other [ACL] entry to compare against
    # @return [Boolean] whether same objects
    def eql?(other)
      [self.class, entries] == [other.class, other.entries]
    end

    # Generates a hash value for this object
    # @return [Fixnum] hash value of object
    def hash
      [self.class, entries].hash
    end

    private
      # Check each entry in order from array
      def ordered_check(default:, **kwargs)
        entries.each do |entry|
          if entry.match(**kwargs)
            # Check if its an allow or deny acl entry (may not be both)
            return true  if entry.is_allow?
            return false if entry.is_deny?
          end
        end
        return default
      end
  end
end
