require 'open3'

module OodSupport
  module ACLs
    # Object describing a Posix ACL
    class PosixACL < ACL
      # The binary used to get the file ACLs
      GET_FACL_BIN = 'getfacl'

      # The binary used to set the file ACLs
      SET_FACL_BIN = 'setfacl'

      # Name of owner for this ACL
      # @return [String] owner name
      attr_reader :owner

      # Name of owning group for this ACL
      # @return [String] group name
      attr_reader :group

      # Mask set for this ACL
      # @return [Array<Symbol>] mask for this acl
      attr_reader :mask

      # Get ACL from file path
      # @param path [String] path to file or directory
      # @raise [InvalidPath] file path doesn't exist
      # @raise [BadExitCode] the command line called exited with non-zero status
      # @return [PosixACL] acl generated from path
      def self.get_facl(path:)
        path = Pathname.new path
        raise InvalidPath, "invalid path: #{path}" unless path.exist?
        stat = path.stat
        acl, err, s = Open3.capture3(GET_FACL_BIN, path.to_s)
        raise BadExitCode, err unless s.success?
        parse(acl, owner: User.new(stat.uid), group: Group.new(stat.gid))
      end

      # Add ACL to file path
      # @param path [String] path to file or directory
      # @param entry [PosixEntry] entry to add to file
      # @raise [InvalidPath] file path doesn't exist
      # @raise [BadExitCode] the command line called exited with non-zero status
      # @return [PosixACL] new acl of path
      def self.add_facl(path:, entry:)
        path = Pathname.new path
        raise InvalidPath, "invalid path: #{path}" unless path.exist?
        _, err, s = Open3.capture3(SET_FACL_BIN, '-m', entry.to_s, path.to_s)
        raise BadExitCode, err unless s.success?
        get_facl(path: path)
      end

      # Remove ACL from file path
      # @param path [String] path to file or directory
      # @param entry [PosixEntry] entry to remove from file
      # @raise [InvalidPath] file path doesn't exist
      # @raise [BadExitCode] the command line called exited with non-zero status
      # @return [PosixACL] new acl of path
      def self.rem_facl(path:, entry:)
        path = Pathname.new path
        raise InvalidPath, "invalid path: #{path}" unless path.exist?
        _, err, s = Open3.capture3(SET_FACL_BIN, '-x', entry.to_s(w_perms: false), path.to_s)
        raise BadExitCode, err unless s.success?
        get_facl(path: path)
      end

      # Clear all extended ACLs from file path
      # @param path [String] path to file or directory
      # @return [PosixACL] new acl of path
      def self.clear_facl(path:)
        path = Pathname.new path
        raise InvalidPath, "invalid path: #{path}" unless path.exist?
        _, err, s = Open3.capture3(SET_FACL_BIN, '-b', path.to_s)
        raise BadExitCode, err unless s.success?
        get_facl(path: path)
      end

      # Generate an ACL by parsing a string along with options
      # @param acl [#to_s] string describing acl
      # @param kwargs [Hash] extra arguments defining acl
      # @return [PosixACL] acl generated by string and options
      def self.parse(acl, **kwargs)
        entries = []
        acl.to_s.strip.split(/\n|,/).grep(/^[^#]/).each do |entry|
          entries << entry_class.parse(entry)
        end
        mask = entries.detect {|e| e.flag == :mask}
        new(entries: entries - [mask], mask: mask, **kwargs)
      end

      # @param owner [#to_s] name of owner
      # @param group [#to_s] name of group
      # @param mask [PosixACL] mask permissions
      # @see ACL#initialize
      def initialize(owner:, group:, mask:, **kwargs)
        super(kwargs.merge(default: false))
        @owner = owner.to_s
        @group = group.to_s
        @mask = mask
      end

      # Check if queried principle has access to resource
      # @param principle [User, Group] principle to check against
      # @param permission [Symbol] permission to check against
      # @return [Boolean] does principle have access?
      def allow?(principle:, permission:)
        # First check owner entry then check rest of user entries (order
        # matters). If match, then this entry determines access.
        entries.select(&:user_entry?).sort_by {|e| e.user_owner_entry? ? 0 : 1}.each do |entry|
          return entry.has_permission?(permission: permission, mask: mask) if entry.match(principle: principle, owner: owner, group: group)
        end

        # Then check groups (order independent). Entry only determines access
        # if it contains requested permission.
        groups = entries.select {|e| e.group_entry? && e.match(principle: principle, owner: owner, group: group)}.map do |entry|
          entry.has_permission?(permission: permission, mask: mask)
        end

        unless groups.empty?
          # Found matching groups so check if any give access
          groups.any?
        else
          # Failed to find any matching groups so check "other" entry
          entries.detect(&:other_entry?).has_permission?(permission: permission, mask: mask)
        end
      end

      # Convert object to string
      # @return [String] the string describing the object
      def to_s
        (entries + [mask]).join(",")
      end

      # Convert object to hash
      # @return [Hash] the hash describing this object
      def to_h
        super.merge owner: owner, group: group, mask: mask
      end

      private
        # Use PosixEntry for entry objects
        def self.entry_class
          PosixEntry
        end
    end

    # Object describing single Posix ACL entry
    class PosixEntry < ACLEntry
      # Valid flags for an ACL entry
      VALID_FLAG = %i[ user group mask other ]

      # Valid permissions for an ACL entry
      VALID_PERMISSION = %i[ r w x ]

      # Regular expression used when parsing ACL entry string
      REGEX_PATTERN = %r[^(?<default>default:)?(?<flag>#{VALID_FLAG.join('|')}):(?<principle>\w*):(?<permissions>[#{VALID_PERMISSION.join}\-]{3})]

      # Is this a default ACL entry
      # @return [Boolean] whether default acl entry
      attr_reader :default

      # Flag set on ACL entry
      # @return [Symbol] flag on acl entry
      attr_reader :flag

      # Permissions of ACL entry
      # @return [Array<Symbol>] permissions of acl entry
      attr_reader :permissions

      # @param default [Boolean] whether default acl entry
      # @param flag [#to_sym] flag for entry
      # @param permissions [Array<#to_sym>] list of permissions for entry
      # @see ACLEntry#initialize
      def initialize(default: false, flag:, permissions:, **kwargs)
        @default = default
        @flag = flag.to_sym
        @permissions = permissions.map(&:to_sym)
        super(kwargs)
      end

      # Do the requested args match this ACL entry?
      # @param principle [User, Group, #to_s] requested principle
      # @param owner [String] owner of corresponding ACL
      # @param group [String] owning group of corresponding ACL
      # @raise [ArgumentError] principle isn't {User} or {Group} object
      # @return [Boolean] does this match this entry
      def match(principle:, owner:, group:)
        principle = User.new(principle) if (!principle.is_a?(User) && !principle.is_a?(Group))
        return false if default_entry?
        p = self.principle
        p = owner if user_owner_entry?
        p = group if group_owner_entry?
        if (principle.is_a?(User) && group_entry?)
          principle.groups.include?(p)
        elsif (principle.is_a?(User) && user_entry?) || (principle.is_a?(Group) && group_entry?)
          principle == p
        elsif other_entry?
          true
        else
          false
        end
      end

      # Is this a default ACL entry
      # @return [Boolean] is this a default entry
      def default_entry?
        default
      end

      # Is this a user-specific ACL entry
      # @return [Boolean] is this a user entry
      def user_entry?
        !default_entry? && flag == :user
      end

      # Is this a group-specific ACL entry
      # @return [Boolean] is this a group entry
      def group_entry?
        !default_entry? && flag == :group
      end

      # Is this an other-specific ACL entry
      # @return [Boolean] is this an other entry
      def other_entry?
        !default_entry? && flag == :other
      end

      # Is this the owner ACL entry
      # @return [Boolean] is this the owner entry
      def user_owner_entry?
        user_entry? && principle.empty?
      end

      # Is this the owning group ACL entry
      # @return [Boolean] is this the owning group entry
      def group_owner_entry?
        group_entry? && principle.empty?
      end

      # Does this entry have the requested permission
      # @param permission [#to_sym] the requested permission
      # @param mask [PosixEntry] the permissions of the mask entry
      # @return [Boolean] found this permission
      def has_permission?(permission:, mask:)
        if user_owner_entry? || other_entry?
          permissions.include? permission.to_sym
        else
          (mask ? permissions & mask.permissions : permissions).include? permission.to_sym
        end
      end

      # Convert object to string
      # @param w_perms [Boolean] whether display permissions
      # @return [String] the string describing this object
      def to_s(w_perms: true)
        %[#{"default:" if default_entry?}#{flag}:#{principle}#{":#{permissions.join}" if w_perms}]
      end

      private
        # Parse an entry string into input parameters
        def self.parse_entry(entry)
          e = REGEX_PATTERN.match(entry.to_s.strip) do |m|
            {
              default:     m[:default] ? true : false,
              flag:        m[:flag],
              principle:   m[:principle],
              permissions: m[:permissions].chars
            }
          end
          e ? e : raise(InvalidACLEntry, "invalid entry: #{entry}")
        end
    end
  end
end
